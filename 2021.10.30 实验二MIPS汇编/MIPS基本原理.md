# 程序执行的基本原理

### 比特（位）、字节、字的区别

1. 比特来自英文bit，表示二进制位。位是计算机内部数据储存的最小单位。

2. 字节是计算机中数据处理的基本单位。计算机中以字节为单位存储和解释信息，规定一个字节由八个二进制位构成，即1个字节等于8个比特（1Byte=8bit）。

   通常1个字节可以存入一个ASCII码，2个字节可以存放一个汉字国标码。

3. 计算机进行数据处理时，一次存取、加工和传送的数据长度称为字（word）。一个字通常由一个或多个（一般是字节的整数位）字节构成。

4. 在MIPS指令体系中，1字=4字节，1字节=8比特

### 指令格式及操作数

MIPS中的操作数分为3类：寄存器，存储器，立即数

#### 寄存器

$0：0号寄存器，其值恒为0
s 0  **s7:程序员变量**
一般用于全局变量/最初即定义了的变量

t 0  **t9:临时变量**
中间变量

#### 立即数

凡是直接出现在指令中的数，即为立即数。

一般指令最后一个字母为“i”的指令为含有立即数的指令

#### 主存单元

主存单元的地址都采用base+offset的方式存储

例如：lw/sw $X,offset(base)

指令集与汇编程序
主存变量声明

| 关键字 | 用途                                      | 对应C变量            |
| :----: | ----------------------------------------- | -------------------- |
| .byte  | 声明8位变量                               | char/unsigned char   |
| .half  | 声明16位变量                              | short/unsigned short |
| .word  | 声明32位变量                              | int/unsigned int     |
| .ascii | 声明字符串，末尾没有‘\0’                  |                      |
| .ascii | 声明字符串，末尾有‘\0’                    |                      |
| .space | 为变量预留指定的字节数（一般取4的整数倍） | string（数组）       |


注：汇编器会倾向于向按照对齐方式为变量分配地址（即4字节一组）

#### 读存储器

##### lb & lbu

读字节：对应C语言中的char型变量

其中lbu将被写入寄存器高24位都填充为0

##### lh & lhu

读半字：对应short型

##### lw

读字：对应int型

没有lwu指令，因为主存中读出和寄存器需要写入的宽度都是32位，不存在符号拓展的需求。

#### 写寄存器

##### lui

寄存器加载立即数高位：

Lui rt immediate 将指令的16位立即数复制到tr寄存器的高16位

往往和ori搭配使用，实现向寄存器中加载一个32位数。如：

```mips
lui $s7,0x55AA
ori $s7.$s7,0x1234
```

最终得到的$s7的值为55AA_1234

#### 算术运算

##### add，sub，addu，subu，addi

add和addu的区别在于前者在溢出后会发生异常，而后者忽略溢出

##### multi，multu，div，divu ; mfhi，mflo，mthi，mtlo

对于乘法，hi保存乘积的高32位，lo保存乘积的低32位；对于除法，hi保存余数，lo保存商。

因此判断是否整除即可判断lo寄存器中是否值为0。

#### 逻辑运算

##### and,andi,or,ori,xor异或,xori,nor或非

#### if-else分支结构

##### beq,bne

结构1：（相等时跳转）

1. beq下面的语句必须是else对应的语句。

2. 为了防止then相关的语句即使在条件不成立时也被执行，需要放置一条j指令跳转到end。

   ```
   beq $s0,$s1,THEN
   	ELSE 对应的语句
   	J END
   THEN:
   	xxxxx
   END:
   	xxxx
   ```

   结构2：（不等时跳转）

		bne $s0,$s1,ELSE
		THEN 对应的语句
		j END
	ELSE:
		XXXX
	END:
		XXXX


##### blez（<=0）,bgez（>=0）, bltz（<0）, bgtz（>0）

##### slt,slti

$slt rd,rs,rt $       当rs小于rt时，rd被写入1，反之被写入0。

其他几种比较情况都是用slt，注意rs与rt即可。

#### while循环

```
WhileLoop:
	条件判断类指令
	循环体
	j WhileLoop
WhileEnd:
```

#### for循环

```
addi $s0,$s0,0
ForLoop:
	slti $t0,$s0,100
	beq $t0,$0,ForEnd
	循环体
	addi $s0,$s0,1
	j ForLoop
ForEnd:
```

#### swich-case结构

略

#### 伪指令

##### move

move $dst,$src   将src寄存器的值赋给dst

##### li

li $t0,100 加载立即数

##### la

la $t0,内存变量名 加载地址到寄存器

#### 移位指令

##### sll,srl

逻辑左移/右移。sll $t0,$s0,16

##### sra

算术右移 sra $t0,$s0,16

注：对于右移，如果高位全部补0，就是逻辑移位，反之如果补符号位，就是算术移位。

##### sllv,srlv,srav

立即数替换成寄存器（寄存器的最低5位被识别为移位量，高27位无意义）

#### 函数操作

调用函数和从函数返回

##### jal,jr

**jal:  jal	label** 实现两个功能，一是将label标号处的地址传递给PC，实现跳转到函数首条指令的目的；二是将jal下一条指令的地址保存到31号寄存器$ra中

**jr:  jr    src** 将src寄存器写入PC，不过一般jal的返回地址都在$ra中，所以函数结尾一般是jr $ra。

##### 参数和返回值 

a 0~ a3传递参数

v 0 ,v1传递返回值