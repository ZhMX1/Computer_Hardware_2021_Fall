# Cache的替换策略-总结

## 计数器的清零和加一策略

连接到计数器的控制信号有

（1）MemRead：本条指令是否需要读取

（2）hit：这个模块有没有被选中，即tag是否对应上，模块外连接的hit是小小hit（此时已经包含G_enable）

（3）B_Enable：在所有模块都没有命中，这里的enable是通过LRU等模块计算出来的新数据加载位置

（4）G_Enable：该组有没有被选中

### 各种数据模式的组合逻辑

**读且有模块命中**：MemRead&&hit（&&G_enable） = clear

**读且无模块命中**->从RAM里加载数据（数据替换、数据写入）：G_Enable&&MemRead&&！clear

**写入：**！hit&&MemRead



### LRU（课下）least-used

**原理**：记录每一个数据块的相对使用情况，最近没有被使用的块被替换。与LFU相比，把最近没有被使用的权重加重。

lru是**写入清零+读命中清零**，访问未命中，需要替换时，则选择计数值最大的块被替换（若最大值并列，随机选择一个）。被替换块的计数器清0，而其它的计数器则加1（选中Group，不满足清零条件，却不读这个block）。

clear：读命中、数据写入/替换

add：组命中、不满足清零、且是在读的时候（写的时候，写入模块清零，别的模块加没有意义）

### LFU least-frequency

原理：记录每一个数据块的使用频率，使用次数最少的被替换。把最近使用的权重加重，在类似LRU的模块中选择权重最小的

clear：数据替换和数据写入的时候清零

add：读命中的时候+1

**注：选择权重最小的进行更新**

### FIFO first-in-first-out

原理：最先装入数据的块被替换

fifo模块的运行模式：只有写入时清零

每块都设定一个两位的计数器，当某块**被装入或被替换（即更新数据的时候）时**该块的计数器清为0，而同组的其它各块的计数器均加1，当需要替换时就选**计数值最大的块被替换掉**。

clear：数据写入/替换

add：组命中、不满足清零、且是在读的时候（写的时候，写入模块清零，别的模块加没有意义）

**与LRU的区别：**LRU读命中的时候清零，但是FIFO读命中不清零，剩下的内容一致
